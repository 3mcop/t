<?php

/**
 * @file
 * Show a modal overlay asking for postcode/login/signup
 */

/**
 * Implements hook_preprocess_page()
 */
function lt_misc_preprocess_page( &$variables ) {

  // Not sure if this is still required.
  // It was for putting the login form in the "account" management button.
  if ( ! user_is_logged_in() ) {
    $variables['login_form'] = drupal_get_form( 'user_login' );
  }

  // Does the current page represent a node?
  if ( !empty( $variables['node']->type ) ) {
    // Allow the page template to be overriden by one specific to the
    // type of the current node.
    $variables['theme_hook_suggestions'][] =
      'page__node_' . $variables['node']->type;
  }
}

function lt_misc_views_query_alter( &$view, &$query ) {

  // Use the presence of a filter called 'flat' to determine whether there
  // is a proximity filter that we can modify.
  if ( ! empty($view->filter['flat']) ) {

    // Using the openlayers_proximity's own bounds calculation.
    // @todo add module dependency on openlayers_proximity.
    $bounds_calculator = new openlayers_proximity_handler_filter_square();
    $bounds = $bounds_calculator->get_bounds( 53.359058, -2.038366, 5 );
    dsm( $bounds );

    // Just being paranoid here. Could views rely on the array pointer
    // being in a particular position? Unlikely.
    $conditions = &$query->where[1]['conditions'];
    $initial_pos = key( $conditions );

    // Get a method of referencing the last element of the array, cus that's
    // where we keep the proximity filter. Is there a more elegant way of
    // doing this? Probably.
    end( $conditions );
    $last_pos = key( $conditions );

    // Set the geobounds for the view query to those for the current user
    // settings.
    dsm( $conditions[$last_pos]['field'] );
    $conditions[$last_pos]['field'] =
      '(openlayers_proximity.lat <= ' . $bounds['north'] .
      ' AND openlayers_proximity.lat >= ' . $bounds['south'] .
      ' AND openlayers_proximity.lon >= ' . $bounds['west'] .
      ' AND openlayers_proximity.lon <= ' . $bounds['east'] . ')';
    dsm( $conditions[$last_pos]['field'] );

    // Finishing off our paranoid treatment of the array pointer.
    _lt_misc_set_array_pointer( $conditions, $initial_pos );

    //print( "<pre>" );
    //print_object_route( $query, '53' );
    //print( "</pre>" );
  }
}

function _lt_misc_set_array_pointer (&$array,$key) { 
  reset ($array); 
  while (key($array) !== $key) { 
    if (next($array) === false) throw new Exception('Invalid key'); 
  } 
} 

function print_object_route( $object, $text, $depth=0 ) {
  if ( $depth > 20 ) {
    return FALSE;
  }

  $array = NULL;

  if ( is_object( $object ) ) {
    //dsm( 'got an object' );
    $array = get_object_vars( $object );
    //dsm( $array );
  }
  elseif ( is_array( $object ) ) {
    //dsm( 'got an array' );
    $array = $object;
  }
  elseif ( strpos( strval($object), $text ) !== FALSE ) {
    //dsm( 'win! got the text' );
    print_object_node( $object, $depth );
    return TRUE;
  }
  else {
    //dsm( 'lose :( end of the line' );
    return FALSE;
  }

  $success = FALSE;
  foreach ( $array as $key => $val  ) {

    if ( strval( $key ) != 'view'  &&
      ( strpos( strval($key), $text ) !== FALSE  ||
      print_object_route( $val, $text, $depth+1 ) ) ) {

        print_object_node( $key, $depth );
        $success = TRUE;
    }
  }
  return $success;
}

function print_object_node( $text, $depth ) {
  $spaces = '';
  if ( $depth > 0 ) {
    $depth += 2;
    for ( $i=0; $i < $depth; $i++ ) {
      $spaces .= '&nbsp;';
    }
  }
  else {
    $spaces .= '* ';
  }

  print $spaces . strval( $text ) . '<br />';
}


